# # SWEA - 숫자 만들기
# '''
# N개의 숫자가 적혀 있는 게임 판이 있음
# +, -, x, / 의 연산자 카드를 숫자 사이에 끼워 넣어
# 수식 계산할 때는 연산자 우선순위는 고려 X, 왼 -> 오 차례대로 계산
# 즉, 1+2*3의 결과는 9

# 주어진 연산자 카드를 사용해 수식 계산 시, 결과가 최대가 되는 수식과 최소가 되는 수식 찾고, 두 값의 차이 구함
# '''

# def get_max_min(cnt, operators, crt_res):
#     global min_res, max_res
#     '''
#     :param cnt: 현재 연산자 개수
#     :param operators: 현재 operators
#     :param crt_res: 현재까지의 연산 결과
#     '''
#     if cnt >= N-1:
#         # print(f'cnt: {cnt}, crt_res: {crt_res}\noperators: {operators}')
#         if crt_res < min_res:
#             min_res = crt_res
#         if crt_res > max_res:
#             max_res = crt_res
#         return
    
#     # operator를 for문으로 반복해서 돌림
#     # 만약 1번 항목 보고 -> 2번 항목 보고 -> 3번까지 보면 다시 돌아감
#     # -> 2번 보던 시점으로 돌아가야 함
#     for op in range(4):
#         if operators[op] > 0:
#             # 매번 시점마다 빼고 더하기
#             cnt += 1
#             operators[op] -= 1
#             if op == 0:
#                 nxt_res =  crt_res + numbers[cnt]
#             elif op == 1:
#                 nxt_res = crt_res - numbers[cnt]
#             elif op == 2:
#                 nxt_res = crt_res * numbers[cnt]
#             else:
#                 nxt_res = int(crt_res / numbers[cnt])
#             get_max_min(cnt, operators, nxt_res)
#             operators[op] += 1
#             cnt -= 1
            

# T = int(input())
# for t in range(1, T+1):
#     min_res = 100000001
#     max_res = -100000001
#     # 숫자의 개수 N
#     N = int(input())
#     # +, -, *, / 순서대로 연산자 카드 개수
#     operators = list(map(int, input().split()))
#     # 수식에 들어가는 N 개의 숫자
#     numbers = list(map(int, input().split()))[:N]
#     '''
#     0.
#     숫자 사이에 연산자를 하나씩 넣어보고, 연산을 진행해야 함
#     연산자를 모두 사용한 시점에, 연산 후 결과 도출
#     그럼 + 하나 쓴 세계 -> + 둘 쓰는 세계 / + 하나, - 하나 쓰는 세계
#     이렇게 이어져야 하므로 DFS로 풀이함
    
#     1.
#     + 하나 쓰고, 그 다음 거에 순서대로 넣고 ... 연산자 개수를 하나씩 줄이면서 0으로 만들기
#     만약 모든 연산자를 사용했다면 -> 어떻게 판단할까?: 횟수로 -> 모든 연산자 사용하면 N-1회차가 되지 않나?
#     N-2가 됨(0부터 시작할 경우에) -> N-1이 되면 연산 후 갱신 
#     연산 후 결과를 현재 최대/최소와 비교해서 갱신
#     '''
#     get_max_min(0, operators, numbers[0])

#     # 결과
#     res = max_res - min_res
#     print(f'#{t} {res}')

# PRO - 단어암기장
'''
# 0
init
- 각 tc 처음에 호출됨
- 크기가 N*M인 암기장 주어짐
- N 최대 20,000 / M 최대 1,000

writeWord(mId, mLen)
- ID가 mId이고, 길이가 mLen인 단어가 주어지면
- 위 규칙에 맞게 암기장에 쓴 후 쓰여진 위치의 "행 번호"를 반환함
- 암기장에 주어진 단어를 쓸 수 없다면, -1을 반환함
- ID값은 1부터 시작해 함수가 호출될 때마다 1씩 증가 => 함수 호출 될 때마다 1씩 증가하네~

eraseWord(mId)
- ID값이 mId인 단어를 암기장에서 지움
- 지우기 전 적힌 위치의 행 번호를 반환함
- 이미 지워졌거나, 적힌 적이 없는 단어의 ID가 주어지면 -1 반환
'''

'''
# 1
- 매번 0행부터, 0열부터 조회해야 할까?
- 행별로 빈칸 개수와 길이를 저장해두면 되는 거 아닐까?
    - 개별로 저장해둘 것인가? : 한다면 시작 열 번호, 길이
    - 조회가 빠른 쪽은? dictionary 빈칸 1: 필요 없음 2 ~ M
    - 'key: 길이 value: 시작 인덱스의 트리? - 최솟값만 뽑으면 되니까'
    - 추가로, min heap의 pop 시간복잡도는 O(1)이라고~~
    - 물론ㅠ 이걸 위해서는 O(logN)의 삽입이 필요함


# 2
- 이상한 점: 한 행에 적혀있는 단어 최대 개수가 60개 이하임을 보장
    - 왜? ... 길이가 2인 단어만 있다면 500개도 넣을 수 있을텐데
    - 이상하다... -> 진짜 모르겠네 이걸 왜 보장해주나?
    - 60개가 넘어가면 시간복잡도가 급격히 커지는, 그런 자료구조가 있나?
=> 칸 단위가 아니라 단어 단위로 보면 시간복잡도가 커지는 구간이 생김
    -> 최대 시간을 막아줌
    
# 3
- writeWord 시뮬레이션
- 단어가 하나 들어옴 -> 빈 공간에 넣어봄
- 다음 단어가 들어옴 -> 0행부터 빈 공간을 찾아봄
- 만약 특정 행에 대한 빈 공간이 없을 경우, 다음 행으로 넘어감

# 4
- eraseWord 시뮬레이션
- ID를 입력받음
- 암기장에 있는 값인지, 아니면 없는 값인지 확인함 <- 중복은 없을 테니까 set으로 관리해도 될 것 같고
- 근데, 만약 더 큰 값이 들어있다면 에러가 발생할 거임
    => 그냥 55000의 index를 가진 list를 생성하고, 값을 t/f로 저장 - 1, 2, 3, 4, 5
- 그럼 위치는 따로 저장해두고 -> t/f로 조회했을 때 f이면 패스 / t이면 위치 조회
- 그리고 비워줘야하니까 길이도 저장해둬야 함
- 그러면 -> eraser를 위해서는
    1. 현재 단어암기장에 존재하는 ID 목록 - 
    2. 현재 단어암기장에 존재하는 ID별 시작 인덱스
    3. 현재 단어암기장에 존재하는 ID별 단어 길이
    이렇게.
    1따로 2, 3 같이 이렇게 저장해두면 쓰기 편할듯 (별도의 dict)
    -> 1 따로 할 필요가 있을까?

# 5
- 시간복잡도
- writeWord를 실행 해
- 각 행 별로 조회를 해(최대 20,000) * 50,000 => 10억
    - 넣을 수 있으면 값을 넣어.. -> ID 목록에 true -> O(1)
    - 시작 인덱스랑 단어 길이도 적어줌 -> O(1)
- 아니면, 길이별로: 최소 인덱스를 저장해두면 어떨까?
    - 관리 방법이 잘 떠오르지 않음
- 아니면, 행별로 저장하되, 길이별로도 저장해두면 어떨까?

# 6
시뮬레이션
- N = 5, M = 5
- 행별 길이 저장소 {0: {5: {0}})} # {행: {길이: 시작인덱스}}
- writeWord(1, 3)
- 행별 길이 저장소 {0: {5: {-1}, 2: {3}}} # {행: {길이: 시작인덱스}}
- 한 가지 간과한 점: 단어의 길이보다 긴 공간에는 해당 단어를 기록할 수 있음

- 판단해야 하는 것 - 길이! 넣을 수 있다 없다를 판단해야 함

=> 세그먼트 트리를 사용해야 할 것 같음
1. 각 행별로 max 빈칸 길이를 저장
2. min 
=> 세그먼트 트리
'''

# 26-01-26
'''
모든 벌꿀을 살피면서, 값이 최대가 되는 경우를 찾자 -> 일단 전체 탐색
'''
T = int(input())
for tc in range(1, T+1):
    N, M, C = map(int, input().split())
    
    grid = []
    for i in range(N):
        row = list(map(int, input().split()))
        grid.append(row)
    print(grid)

    # N-1만큼 돌면 됨 -> 다른 것도!!!